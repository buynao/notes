## 单线程
单线程，即js只在一个线程上进行。

同时只能执行一个任务，其他任务须等待。

原因就是，创作者不想让js变得太复杂，从一开始创造这个语言，就是采用得单线程模型。

多线程的复杂在于，共享状态，交互状态时的性能开销。

这些都是一开始js所不需要的。

单线程的缺点就是：
- 无法利用多核cpu
- 错误会引起应用的整个退出
- 大量的计算，导致其他程序的无法执行


比如在浏览器上js与UI公用一个线程。js的长时间执行，导致ui的渲染中断。

在node里，js的长时间计算，导致cpu占用，与后续的异步I/O发不出调用，已完成异步I/O的回调得不到及时执行。

针对这个情况的解决方案：

浏览器端的html5制定了web workers的标准，即工作线程。

工作线程不阻塞主线程。通过消息传递的方式来传递运行结果。

工作线程不得访问主线程的UI，即不能操作dom。

Node端的解决方案与web workers的思路一样，采用的是child—process.即子进程。

通过将计算分发到各个子进程，可以将大量计算分解。在通过子进程之间的事件消息来传递结果，以此保持应用模型的简单和低依赖。

## queue，消息队列or任务队列

js运行时，除了一个**运行进程**，引擎还会提供一个消息队列（msg queue），队列里边是各种需要当前程序处理的消息。

新的消息进入，会自动排在最后边，先进先出的原则，排队买票的原理。谁先排队，谁就先买到票。

**运行线程**也就是栈，当前栈为空时，只要发现消息队列不为空就会取出排在第一位的那个消息，放在当前栈。执行它对应的函数。如此循环～

即卖票的，当自己手里的活干完以后，只要看到有人在另一边窗口排队买票，就会继续向排在最前边的人，让他到自己的当前（生成一个chu shi初始栈）对他卖票。

每条消息都与一个回调函数相关联，也就是说运行线程处理这条消息时，就会执行相应的回调函数。

所以进入消息队列的消息，必然会有一个回调函数。

使用**setTimeout**，会在指定时间内向消息队列添加一条消息。如果消息队列当前没有其他消息。那么这条消息会立即处理。否则必须得等到其他消息处理完以后，才会执行。

所以**setTimeout**的执行时间，只是一个最早的执行时间，可能并不会太准确。

## Event Loop

```
while(queue.waitForMessage()){
  queue.processNextMessage();
}
```
事件循环，指的是一直内部循环。
简单来说，会不停的处理消息队列中的消息，即执行消息队列中的函数。

动态的更新消息队列。

js所有任务分成两种：

同步任务，即在js运行进程上执行的任务，前一个任务不执行结束，后一个任务就不会执行。

异步任务，不进入js运行进程，转而进入‘任务队列’的任务，只有‘任务队列’通知主进程，某个异步任务可以执行了，该任务（采用回调函数的形式）才会进入js主进程。

如最常用的ajax，可同步也可异步。

也就是说，js只有一个进程来执行，但是并行的还有其他进程（处理定时器的进程，处理用户输入的进程，处理网络通信的进程等等）。

这些进程通过向queue添加任务，实现与js进程通信。

当主线程stack栈为空时，就会去queue队列中执行排在第一个的程序，这种事件轮询机制，就是event loop。

所有同步任务都在主线程上执行，形成一个执行栈。

主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

主线程不断重复上面的第三步。

只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。

> **Node的event loop**

1. V8引擎解析JavaScript脚本。
2. 解析后的代码，调用Node API。
3. libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。
4. V8引擎再将结果返回给用户。

## 程序，进程，线程

一个程序等于一个进程，打开的浏览器。
线程：浏览器里的js，代码段。

一个进程是由一个线程或多个线程组成。

进程负责资源的调配和分配，线程才是程序的执行单元，负责代码的执行。

每个正在运行的程序（进程），至少包括一个线程，这个线程叫主线程。

浏览器不是单线程的

浏览器的内核时多线程，它们在内核制控下相互配合保持同步。

一个浏览器至少实现三个常驻线程：
- js引擎线程，基于事件驱动单线程执行的，也就是主线程，执行线程。
- gui渲染线程，负责渲染浏览器界面，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时,该线程就会执行。与js引起互斥，其中一个执行，另外一个线程会被挂起。现代的高级浏览器gui的更新会保存在一个队列中等到js引擎空闲时，一次性执行。
- queue＝》浏览器事件事件触发线程，当一个事件触发时，该线程会把事件添加到‘任务队列’的对尾，等待js引擎即主线程的处理。这些事件可来自JavaScript引擎当前执行的代码块如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS是单线程执行的，所有这些事件都得排队等待JS引擎处理。


在Chrome浏览器中，为了防止因一个标签页奔溃而影响整个浏览器，其每个标签页都是一个进程。当然，对于同一域名下的标签页是能够相互通讯的，具体可看 浏览器跨标签通讯。在Chrome设计中存在很多的进程，并利用进程间通讯来完成它们之间的同步，因此这也是Chrome快速的法宝之一。对于Ajax的请求也需要特殊线程来执行，当需要发送一个Ajax请求时，浏览器会开辟一个新的线程来执行HTTP的请求，它并不会阻塞JavaScript线程的执行，当HTTP请求状态变更时，相应事件会被作为回调放入到“任务队列”中等待被执行。
## stack，heap

> stack 栈

也可以理解为主线程。
js正在执行的任务。每个任务被称为帧。

当前栈为空时，就会执行queue里的任务。

```
function f(b){
  var a = 12;
  return a+b+35;
}

function g(x){
  var m = 4;
  return f(m*x);
}

g(21);

```

上述代码调用 g 时，

创建栈的第一帧，该帧包含了 g 的参数和局部变量。

当 g 调用 f 时，第二帧就会被创建，并且置于第一帧之上，当然，该帧也包含了 f 的参数和局部变量。

当 f 返回时，其对应的帧就会出栈。

同理，当 g 返回时，栈就为空了（栈的特定就是后进先出 Last-in first-out (LIFO)）。

> heap 堆

表示内存中一大片非结构化区域的名字，对象都被分配在这。

### 总结
JavaScript是单线程的，同一时刻只能执行特定的任务。而浏览器是多线程的。
异步任务（各种浏览器事件、定时器等）都是先添加到“任务队列”（定时器则到达其指定参数时）。当Stack栈（JS主线程）为空时，就会读取Queue队列（任务队列）的第一个任务（队首），然后执行。