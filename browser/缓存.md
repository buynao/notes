## 浏览器缓存

网页性能优化的其中一个重要方法就是控制浏览器缓存，网上已经有很多介绍关于浏览器缓存的文章。

在此做一个归类作备忘，用来加深记忆。

web开发中常遇到的缓存知识有：服务端缓存，客户端缓存，HTML5的离线存储等等；

此篇文章主要介绍浏览器缓存相关机制，其他缓存相关知识，暂不讨论；

因为针对浏览器缓存，需要客户端和服务端协同完成，所以两者之间需要一个传递信息的桥梁，HTTP的headers就是这座桥，主要用来传递两者之间的信息的。

关于浏览器缓存，主要分为：**强缓存和协商缓存**，其中：

- 性能优化中，强缓存优于协商缓存
- 强缓存一般与协商缓存组合使用

### 强缓存
优先级高于协商缓存，强缓存不向服务器发送请求。

主要用到headers的参数有：**expires(http1.0)**，**cache-control(http1.1)**

### expires

服务端设置的到期时间，当请求时间早于此时间，直接走强缓存，现在一般看到这个响应头，主要为了兼容http1.0去做的。

### cache-control

- 每个资源都可通过 Cache-Control HTTP 标头定义其缓存策略
- Cache-Control 指令控制谁在什么条件下可以缓存响应（请求头设置）以及可以缓存多久（响应头设置）


```
 // 表明资源可以被浏览器、CDN、代理服务器缓存等任何对象缓存，通常不设置，因为max-age默认可以缓存
 Cache-Control: public 
 // 资源只为单个用户缓存，不允许任何中间缓存，常用于私人信息页等
 Cache-Control: private 

 // 表明禁止强缓存，只能走协商缓存
 Cache-Control: no-cache 
 // 表明禁止任何缓存，每次请求必须与服务端进行通信
 Cache-Control: no-store 

 // 相对时间，表示从第一次收到请求后多久秒内走缓存，“max-age=60”表示可在接下来的 60 秒缓存和重用响应
 Cache-Control: max-age=<seconds>

```

### 协商缓存

- 协商缓存会根据[last-modified/if-modified-since]或者[etag/if-none-match]来进行判断缓存是否过期
- 协商缓存无法减少请求数的开销，但是可以减少返回的正文大小。一般来说，对于勤改动的html文件，可以使用协商缓存

协商缓存主要用到headers的参数的有：

### last-modified/if-modified-since

- last-modified是服务端返回的资源上一次更改时间，浏览器拿到这个时间后，在下一次请求该资源时，**在请求头中带上if-modified-since:[保存的last-modified的值]**。服务端根据两个参数值进行比较，一致的话，代表资源没有进行过修改，服务端返回请求体为空，请求头为304，让浏览器在缓存中读取资源。
- 保存时间以秒为单位，会出现误差，1S内多次修改的话
- 各个浏览器读取的时间可能不一致，也会出现误差

### etag/if-none-match
- etag是服务端返回的一个验证令牌，浏览器拿到这个令牌后，在下一次请求该资源时，**在请求头中带上if-none-match:[保存的etag的值]**。服务端根据两个参数值进行比较，一致的话，代表资源没有进行过修改，服务端返回请求体为空，请求头为304，让浏览器在缓存中读取资源。
- etag能够解决last-modified的一些缺点，但是etag每次服务端生成都需要进行读写操作，而last-modified只需要读取操作，从这方面来看，etag的消耗是更大的
- Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

### <TIPS>

#### 浏览器的资源请求流程
1. 浏览器发送请求前，根据请求头的expires和cache-control判断是否命中强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。

2. 没有命中强缓存规则，浏览器会发送请求，根据请求头的last-modified和etag判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。

3. 如果前两步都没有命中，则直接从服务端获取资源。

#### 优先级关系
Cache-Control http1.1 > Expires > Pragma http1.0来决定是否 (200 from cache)

#### webview
如果页面是在webview里打开的，上边介绍的设置，未必会起作用，需要提供额外的配置标志，才能确保http缓存是否得到启用。

#### 消灭304
如果你经常看到许多304(不包括点击按钮这种刷新方式)。

304这个表示，请求发送到后端，经过协商缓存判定资源可以继续使用，直接使用本地缓存。

在这种方式下，虽然后端不会传相应的资源，但是请求的一来一回也是会花费时间的。

并且给服务器一定的压力，所以性能优化中，有一条叫做消灭304 。尽可能的设置久缓存时间。

#### status 200 from cache

Chrome在高版本更新了缓存策略，from cache分成了
1. from disk cache(磁盘缓存)
2. from memory cache(内存缓存)

from disk cache 常见于关闭浏览器，重新打开时遇到，读取速度2~10ms，和磁盘的IO相关。

from memory cache 页面多次刷新资源就会存到内存里，读取速度为0,


#### 用户行为缓存

用户操作 | 强缓存（Expires/Cache-Control）| 协商缓存（Last-Modified/Etag）
---|---|---|
地址栏回车 | 有效 |有效|
页面链接跳转 |有效|有效|
新开窗口 |有效|有效|
前进、后退 |无效|有效|
Ctrl+F5刷新 |无效|无效|

